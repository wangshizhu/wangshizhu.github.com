---
layout: second_template
title: log系统
category: component_design
tagline: "Supporting tagline"
tags : [component_design]
permalink: log-component
---

[condition_variable]: /condition_variable

职业生涯中涉及的服务端业务场景都需要log系统，Go服务、C++游戏服务器都需要一个完备的log系统，目前接触最多的就是用这两种语言写的服务，所以以这两种语言分别实现了log系统。

实现log系统之前肯定需要列出log系统模型

### log系统模型
--------------------------------------------------

这篇[文章][condition_variable]简单提到了log系统的设计思想，下面列出详细：

* 业务线程（生产者）产生log数据
	
	假设此线程为1#线程
	
* log系统内部线程与业务线程属于两个不同的线程
	
	接收业务线程log消息的线程为2#线程
	
	既然是两个不同的线程就涉及到消息队列，传统做法通过加锁实现，这样势必可能造成业务线程阻塞，**还有一种做法是使用无锁队列**，下面会以这两种方法做测试

* log系统处理log数据（消费者）
	
	写log消息的线程为3#线程
	
	log系统实现真正的异步写log，注意：写log消息的3#线程和2#线程是两个不同的线程
	
* 需要支持按天、按大小生成log文件
	
	通常需要每天产生一个log文件，即当日00:00:00需要创建log文件
	
	有时需要按照大小重新生成log文件，例如超过10M即重新创建
	
* 需要支持不同的logger

	通常有个主logger，而实际生产中有需求需要与主logger的日志分开，例如游戏服务器中的AI模块产生的log消息需要单独记录，便于分析问题
	
	不同logger需要产生不同的log文件
	
* log消息的内容
	
	log消息的内容需要包含以下：
	
	- 产生log消息的时间

	- 产生log消息的业务线程ID

	- log级别

	- 产生log消息的文件、函数、行数
	
	- 用户层的消息内容

* log消息需要支持流式写入

	这个是可选项，流式写入就像下面这种形式：
	
		LOGERR()<<"log msg,id:%d,name:%s"<<id<<name;
		
	非流式写入就像下面这种形式：
	
		LOGERR("log msg,id:%d,name:%s",id,name);
		
### 直观表现
--------------------------------------------------

结合上面的模型可以log系统产生的log数据直观表现：

* log文件名
	
	LoggerName-2021-04-20-00-00-00.log
	
* log内容

	2021-04-20-00-00-00 thread_id log_level file_name funtion_name line_number      log_msg



	
