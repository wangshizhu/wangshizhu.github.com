---
layout: second_template
title: InnoDB Buffer Pool
category: mysql
tagline: "Supporting tagline"
tags : [mysql]
permalink: innoDB-buffer-pool
---

[Buffer_Pool]:assets/themes/my_blog/img/Buffer_Pool.jpg

InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使只需要访问一个页的一条记录，
那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不立即把该页对应的内存空间释放掉，而是将其缓存起来，
这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了

为了缓存磁盘中的页，在MySQL服务器启动的时候就向操作系统申请了一片连续的内存，这块内存叫做Buffer Pool

Buffer Pool的大小可以在服务器的配置中字段innodb_buffer_pool_size指定：

	[server]
	innodb_buffer_pool_size = 268435456
	
innodb_buffer_pool_size以**字节**为单位，不能低于最小值5M，低于最小值时按照最小值5M设定

### Buffer Pool 简易结构
--------------------------------------------------

Buffer Pool的结构可以参考此图：

![Alt text][Buffer_Pool]

图中缓存页对应着磁盘上的页，大小都为16K，每个缓存页对应这个一个控制块，控制块包含的信息可以在结构图中看到，每个缓存页对应的控制块占用的内存大小是相同的，
它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边，在MySQL5.7.21这个版本中，每个控制块占用的大小是808字节。
而设置的innodb_buffer_pool_size并不包含这部分控制块占用的内存空间大小，也就是说InnoDB在为Buffer Pool向操作系统申请连续的内存空间时，
这片连续的内存空间一般会比innodb_buffer_pool_size的值大5%左右

从图中看到有碎片空间，所有的缓存页和控制块是一段连续的内存空间，碎片空间是这段连续内存空间分配完缓存页和控制块后所剩下的

### Free链表
--------------------------------------------------

从图中看到有Free链表，而链表的节点是控制块

当启动MySQL服务器的时候，需要完成对Buffer Pool的初始化过程，就是先向操作系统申请Buffer Pool的内存空间，然后把它划分成若干对控制块和缓存页。
但是此时并没有真实的磁盘页被缓存到Buffer Pool中，之后随着程序的运行，会不断的有磁盘上的页被缓存到Buffer Pool中

当从磁盘加载数据到缓存页时，需要找到未使用的缓存页，那么这个未使用的缓存页就是由Free链表管理的（严格的说它管理着缓存页对应的控制块），取出空闲的缓存页，
并且把该缓存页对应的控制块的信息填上（就是该页所在的表空间、页号之类的信息），然后把该缓存页对应的free链表节点从链表中移除

同时这个链表的基础信息由一个基节点管理着，这个基节点包含的一些基础数据可以从图中看出（链表的头节点、链表的尾节点、节点数量等）

在从磁盘加载一个页之前，需要判断这个页是否在缓存中，这个判断过程访问了以**表空间+页号**为key、缓存页为value的hash表，
如果有，直接使用该缓存页就好，如果没有，那就从free链表中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置

### Flush链表和刷新
--------------------------------------------------

从结构图中看到有一个Flush链表，顾名思义，这个链表管理着修改过的缓存页对应的控制块（已经修改的缓存页也称为脏页dirty page），为以后将数据同步到磁盘准备的，
Flush链表的基础数据同样由一个基节点管理着

刷新脏页到磁盘是由存储引擎层**专门的线程**每隔一段时间触发，刷新有两种方案：

* 从LRU链表的冷数据中刷新一部分页面到磁盘

	线程会定时从LRU链表尾部开始扫描一些页面，扫描的页面数量可以通过系统变量innodb_lru_scan_depth来指定，如果发现脏页，会把它们刷新到磁盘。
	这种刷新页面的方式被称之为**BUF_FLUSH_LRU**
	
* 从flush链表中刷新一部分页面到磁盘

	线程也会定时从flush链表中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为**BUF_FLUSH_LIST**
	
有时候线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到Buffer Pool时没有可用的缓存页，
这时就会尝试看看LRU链表尾部有没有可以直接释放掉的未修改页面，
如果没有的话会不得不将LRU链表尾部的一个脏页同步刷新到磁盘（和磁盘交互是很慢的，这会降低处理用户请求的速度）。
这种刷新单个页面到磁盘中的刷新方式被称之为**BUF_FLUSH_SINGLE_PAGE**。

有时候系统特别繁忙时，也可能触发用户线程批量的从flush链表中刷新脏页的情况