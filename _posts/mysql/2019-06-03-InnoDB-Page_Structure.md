---
layout: second_template
title: InnoDB数据页结构
category: mysql
tagline: "Supporting tagline"
tags : [mysql]
permalink: innoDB-page-structure
---

[row-format]:/innodb-row-format-compact
[innodb_ruby]:https://github.com/jeremycole/innodb_ruby

***
* ### 测试环境 ###
	
	MySQL 5.6

	innodb_ruby(关于它的使用可以参考它的[github][innodb_ruby])

***
* ### 数据页 ###
	
	在[行格式文章][row-format]中提到了一些页的概念,它是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。InnoDB为了不同的目的而设计了许多种不同类型的页，例如：存放表空间头部信息的页，存放Insert Buffer信息的页，存放INODE信息的页，存放undo日志信息的页等。而我们的数据就存放在官方所称的**索引页**中，通常使用过程中更多称为**数据页**

***
* ### 数据页结构 ###

	|名称|占用空间大小|描述|
	|-|-|-|
	|File Head(文件头部)|38字节|页的一些基本信息|
	|Page Head(页头部)|56字节|数据页的一些基本信息|
	|Infimum + Supremum(最小记录和最大记录)|26字节|两条系统插入的行记录|
	|User Records(用户真实记录)|不确定|实际存储的行记录数据|
	|Free Space(空闲空间)|不确定|数据页中未使用的空间|
	|Page Directory(页面目录)|不确定|数据页中某些记录的相对位置|
	|File Trailer(文件尾部)|8字节|校验页是否完整|


	我们的数据就存储在User Records这部分空间，User Record在页的建立起初并不存在，User Records这部分空间是从空闲空间Free Space逐渐划分而来，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页。我们先创建一张表，并插入一些数据去解释各个部分的作用。如下：

		USE test;
		CREATE TABLE `t_test_page` (
			c1 INT NOT NULL DEFAULT '0',
			c2 CHAR NOT NULL DEFAULT '',
			PRIMARY KEY(c1)
		)ENGINE INNODB CHARSET=ASCII ROW_FORMAT=COMPACT;

		INSERT INTO t_test_page(c1,c2) VALUES (0,"a"),(1,"b"),(2,"c");

	**把c1列设置为主键是因为在compact行格式中就没必要为我们去创建那个所谓的 row_id 隐藏列了**，用户真实数据在User Records空间中是以**单向链表**方式存储的，每条记录可以认为是链表的节点，那么节点信息记录在行数据中的额外信息，我们先看看这3条记录的头信息，为了看起来直观下面的信息做了简单修改，同时只列举了讨论问题所需的字段，详细行格式包含内容可参考[行格式文章][row-format]：

	|记录|next|type|heap_number|n_owned|min_rec|deleted|
	|-|-|-|-|-|-|-|
	|Infimum|125|2|0|1|false|false|
	|Supremum|112|3|0|4|false|false|
	|(0,"a")|157|0|2|0|false|false|
	|(1,"b")|189|0|3|0|false|false|
	|(2,"c")|112|0|4|0|false|false|

	1. deleted

		这个字段标识了当前记录是否被删除，只占用一个二进制位，0：未被删除 1：被删除。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，只是打一个删除标记，所有被删除掉的记录都会组成一个垃圾链表，在这个链表中的记录占用的空间称为可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。而设置被删除标记和加入到垃圾链表是两个阶段

	2. min_rec

		B+树的每层非叶子节点中的最小记录都会添加该标记,我们插入的3条记录的min_rec值都是0，意味着它们都不是B+树的非叶子节点中的最小记录

	3. n_owned

		以此记录为页面目录节点所拥有的记录数量，下面页面目录会详细解释，我们的3条记录对应的no_owned字段值都是0

	4. heap_number

		表示当前记录在本页中的位置，我们插入的3条记录在本页中的位置分别是：2、3、4，我们从分析工具打出的数据看到system records项，这就是开头提到的2条系统插入的行记录，而这2条记录的heap_number字段对应的值正是0、1，这2条记录其中一条是最小记录，一条是最大记录，这2条记录都是由5字节大小的头信息和8字节的固定部分组成的。**我们的记录有大小之分，对于一条完整的记录来说，比较记录的大小就是比较主键的大小**，这2条记录存放在称为Infimum + Supremum的部分

	5. type

		这个字段表示当前记录的类型，一共有4种类型的记录，0：表示普通记录，1：表示B+树非叶节点记录，2：表示最小记录，3：表示最大记录。从上表我们可以看出来，我们自己插入的记录就是普通记录，而最小记录和最大记录的type值分别为2和3

	6. next

		这个字段表示**从当前记录的真实数据到下一条记录的真实数据的地址偏移量（所在页的起始偏移）**。如果写过单向链表都知道，链表的每个节点里都有一个指向下一个节点的指针，而这里记录了下一条记录的真实数据偏移量，所以这个链表类型这样：

			最小记录Infimum------>(0,"a")------>(1,"b")------>(2,"c")------>最大记录Supermum

		**下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定最小记录Infimum 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是最大记录Supremum** ，虽然每条记录的指向以链表形式，但是记录的存储形式是这样的：

		最小记录Infimum|最大记录Supermum|(0,"a")|(1,"b")|(2,"c")

		每条记录还有一个字段offset，它表示的是记录在页中的地址偏移量：

		|记录|offset|
		|-|-|
		|Infimum|99|
		|Supremum|112|
		|(0,"a")|125|
		|(1,"b")|157|
		|(2,"c")|189|

		有了上面几张表和解释，思考一下这5条数据的next字段为什么是125、112、157、189、112



