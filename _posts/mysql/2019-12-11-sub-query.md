---
layout: second_template
title: 子查询基础
category: mysql
tagline: "Supporting tagline"
tags : [mysql]
permalink: sub-query
---

我们都见过在查询语句中又嵌套了查询语句，那么这个嵌套的查询语句称为**子查询**

子查询以外的查询称为**外层查询**

### 子查询出现的位置
--------------------------------------------------

按照子查询出现的位置分为：

* select子句中
	
	例如：
		
		select (select * from table_name limit 1);
	
* from子句中
	
	例如：
	
		select x,y from (select pos_x as x,pos_y as y from t_player where player_id=1) as t
		
	from子句中的查询结果相当于一个表，MySQL把这种由子查询结果集组成的表称为派生表
	
* where 或者 on子句中
	
	例如：
	
		select * from t_player where player_id in (select player_id from t_equipment where level > 100);
		
### 子查询返回的结果集
--------------------------------------------------

按照它们返回的不同结果集类型而把这些子查询分为不同的类型：

* 标量子查询
	
	只返回一个单一值的子查询称为标量子查询。标量子查询可以作为一个单一值或者条件表达式的一部分出现在查询语句。例如：
	
		select (select level from t_player limit 1)
		SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2);
	
* 行子查询

	子查询返回一条记录，不过这条记录需要包含多个列（只包含一个列是标量子查询）。例如：
	
		SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);

* 列子查询
	
	列子查询就是查询出一个列的数据，不过这个列的数据需要包含多条记录（只包含一条记录就成了标量子查询。例如：
	
		SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);
	
* 表子查询
	
	表子查询就是查询结果既包含很多条记录，又包含很多个列。例如：
	
		SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);
		
### 与外层查询关系来区分子查询
--------------------------------------------------

* 不相关子查询

	如果子查询可以单独运行出结果，而不依赖于外层查询的值，把这个子查询称之为不相关子查询

* 相关子查询

	如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为相关子查询。例如：

		SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);
		
	子查询中有一个搜索条件是n1 = n2，n1是表t1的列，也就是说子查询的执行需要依赖于外层查询的值，所以这个子查询就是一个相关子查询
	
### 子查询在where条件语句中
--------------------------------------------------

* 使用=、>、<、>=、<=、<>、!=、<=>作为条件运算符时
	
	这种情况的子查询只能是标量子查询或者行子查询，也就是子查询的结果只能返回一个单一的值或者只能是一条记录。例如：
	
		SELECT * FROM t1 WHERE m1 < (SELECT MIN(m2) FROM t2);
		SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);
		
* [NOT] IN/ANY/SOME/ALL

	对于列子查询和表子查询来说，它们的结果集中包含很多条记录，这些记录相当于是一个集合，可以通过这些关键字与集合形成条件表达式。例如：
	
		SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);
		
		SELECT * FROM t1 WHERE m1 > ANY(SELECT m2 FROM t2);
		
		SELECT * FROM t1 WHERE m1 > ALL(SELECT m2 FROM t2);
		
	顺便提一下ANY、SOME、ALL的语意：
	
	ANY和SOME是同义词，以这个查询为例：
	
		SELECT * FROM t1 WHERE m1 > ANY(SELECT m2 FROM t2);
		
	意思是只要m1大于结果集中的某个值，那么表达式结果为TRUE，否则为FALSE。就这个查询而言就是m1大于结果集的最小值即为TRUE。所以这个子查询可以替换为:
	
		SELECT * FROM t1 WHERE m1 > (SELECT MIN(m2) FROM t2);
		
	= ANY相当于判断子查询结果集中是否存在某个值和给定的操作数相等，它的含义和IN是相同的
	
	ALL的语意用这个查询为例：
	
		SELECT * FROM t1 WHERE m1 > ALL(SELECT m2 FROM t2);
		
	意思是m1大于结果集中的所有值，那么表达式结果为TRUE，否则为FALSE。就这个查询而言就是m1大于结果集的最大值即为TRUE。所以这个子查询可以替换为:
	
		SELECT * FROM t1 WHERE m1 > (SELECT MAX(m2) FROM t2);
		
* EXISTS子查询

	EXISTS的语意是是否存在，例如下面查询：
	
		SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2 WHERE m2 > 1);
		
	它的语意就是子查询是否有记录，有记录即为TRUE，否则为FALSE。对于子查询的结果列、子查询的行并不关心
	
### 子查询语法
--------------------------------------------------

* 子查询必须用小括号扩起来	

* 在SELECT子句中的子查询必须是标量子查询

* 对于[NOT] IN/ANY/SOME/ALL子查询来说，子查询中不允许有LIMIT语句

* 不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询
	
	例如这样的查询：
	
		DELETE FROM t1 WHERE m1 < (SELECT MAX(m1) FROM t1);



