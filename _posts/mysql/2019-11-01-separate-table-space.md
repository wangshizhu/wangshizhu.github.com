---
layout: second_template
title: InnoDB独立表空间
category: mysql
tagline: "Supporting tagline"
tags : [mysql]
permalink: separate-innodb-table-space
---

[data_directory]:/data-directory
[leaf_type]:/innoDB-page-structure
[separate_table_space_struct]:assets/themes/my_blog/img/table_space.jpg

--------------------------------------------------
### 宏观结构

在数据目录这篇[文章][data_directory]提到**在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间**

独立表空间结构如图![Alt text][separate_table_space_struct]

#### 区extent：

**我们知道InnoDB页是存储数据的基本单位，**对于页的管理是通过区extent，一个区包含64个**物理位置连续的页**，也就是1M

**每个区对应一个结构XDES Entry**

我们知道B+树节点（即页）之间是通过双向链表建立关系，页对应着磁盘上的物理位置，所以应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序I/O，
如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机I/O。而磁盘的速度和内存的速度差好几个数量级，所以有了区extent的概念

在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据十分非常多的时候，可以一次性分配多个连续的区

从结构图中可以看到XDES Entry的组成：

* Segment ID

	每一个段都有一个唯一的编号，Segment ID字段表示就是该区所在的段

* List Node

	这个部分可以将若干个XDES Entry结构串联成一个链表，列表的结构参照结构图

* State

	区大体上可以分为4种类型：

	+ 空闲的区：现在还没有用到这个区中的任何页面，记为FREE
	
	+ 有剩余空间的碎片区：表示碎片区中还有可用的页面，记为FREE_FRAG
	
	+ 没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面，记为FULL_FRAG

	+ 附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位，记为FSEG

	**处于FREE、FREE_FRAG以及FULL_FRAG这三种状态的区都是独立的，直属于表空间；而处于FSEG状态的区是附属于某个段的**

* Page State Bitmap

	这个部分共占用16个字节，也就是128个比特位。前面提到一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，
对应区中的一个页。比如Page State Bitmap部分的第1和第2个比特位对应着区中的第1个页面，第3和第4个比特位对应着区中的第2个页面。
这两个比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用


#### 组：
	
256个区记为一组

整个表空间的第一组的第一个区（也就是图中extent 0）前三个页面是固定的，分别是FSP_HDR类型的页、IBUF_BITMAP类型的页、INODE类型的页，关于页类型可以参考这篇[文章][leaf_type]

整个表空间的其余组的第一个区（例如图中的extent 256、extent 512）前两个页面是固定的，分别是XDES类型的页、IBUF_BITMAP类型的页

#### 段segment：

**以索引为例，叶子结点为一个段，非叶子结点为一个段，所以一个索引有两个段，当然还有其他类型的段，例如对于一个包含聚簇索引、二级索引的表，那么它有4个段**

**每个段对应一个结构INODE Entry**

有个应用场景是范围查询，范围查找最终是对B+树叶子节点中的记录进行顺序扫描，如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中，进行范围扫描就有可能触发随机IO。
所以对B+树的叶子节点和非叶子节点进行了划分，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。**存放叶子节点的区的集合是一个段（segment），
存放非叶子节点的区的集合也是一个段，所以段是以区为单位申请存储空间的。** 

上面提到一个区默认占用1M存储空间，所以默认情况下有一个索引的表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表是很大的浪费。
这个问题的根本是申请的区extent都是专区专用的（也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，
即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用），现在为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，
所以又有了碎片fragment区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，
例如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。**碎片区直属于表空间，并不属于任何一个段**。所以此后为某个段分配存储空间的策略是这样的：

* 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的

* 当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间

所以现在段不能仅定义为是某些区的集合，更准确定义是某些零散的页面和一些完整的区的集合。除了索引的叶子节点段和非叶子节点段之外，
InnoDB中还有为存储一些特殊的数据而定义的段，例如回滚段

--------------------------------------------------

### FSP_HDR类型的页

一个表空间只有一个FSP_HDR这样类型的页，从结构图中可以看出它的组成，**它在整个表空间的位置固定**

#### File Header和File Trailer：

页面的头尾是通用的结构

#### File Space Header：

这个部分是用来存储表空间的一些整体属性

|名称|描述|
|-|-|
|Space ID|表空间的ID|
|Not Used|未被使用 忽略|
|Size|当前表空间占有的页面数|
|FREE Limit|尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表|
|Space Flags|表空间的一些占用存储空间比较小的属性|
|FRAG_N_USED|FREE_FRAG链表中已使用的页面数量|
|List Base Node for FREE List|FREE链表的基节点|
|List Base Node for FREE_FRAG List|FREE_FRAG链表的基节点|
|List Base Node for FULL_FRAG List|FULL_FRAG链表的基节点|
|Next Unused Segment ID|当前表空间中下一个未使用的 Segment ID|
|List Base Node for SEG_INODES_FULL List|SEG_INODES_FULL链表的基节点|
|List Base Node for SEG_INODES_FREE List|SEG_INODES_FREE链表的基节点|


#### XDES Entry 0...255：

有256个这样的结构，而上面提到每个这样的结构代表一个区，所以当前组所有区的结构都存储在这块连续的空间





