---
layout: second_template
title: 能使用noexcept就使用noexcept
category: C++
tagline: "Supporting tagline"
tags : [C++]
permalink: noexcept
---

***
* ### noexcept优势 ###

	1. 优化器方面

		在调用外部接口时通常最关心的是这个接口会不会抛出异常，下面是C++98和C++11不会抛出异常的写法:

			// C++98
			void Fun() throw();
			// C++11
			void Fun() noexcept;

		在运行期异常逸出函数Fun时，在C++98异常规格下调用栈会开解到Fun的调用方，程序中止，而在C++异常规格下程序中止前栈只是**可能**会开解，这里的区别在于开解调用栈和可能开解调用栈。

		在带有noexcept声明的函数中，优化器不需要在异常传出函数的前提下，将执行期栈保持在可开解状态，也不需要在异常逸出函数的前提下，保证所有其中的对象以被构造的顺序的逆序完成析构，而throw()异常规格声明的函数没有这样的优化

	2. 标准库方面

		在C++11面前，对以往的标准库优化就是使用移动语意，而受限于过往的实现有一些是强异常安全保证，例如：std::vector::push_back。基于这个事实，这些实现并不能暴力的使用移动语意，除非它知道移动操作不会抛出异常，标准库里的一些函数对于类似这样的优化都保持着“能移动则移动，必须拷贝则拷贝”的原则。而如何知道移动操作不会抛出异常就是借助noexcept。带来的收益就是提高了性能

***
* ### 应用场景 ###
	
	上述提出的优势很诱人，并不是所有场景都适用noexcept，下面是不适合应用noexcept场景：

	1. 在日常编写对外接口时如果使用了noexcept就意味着很长的一段时间接口不会抛出异常，可能随着需求的增加，需要去掉noexcept，这时就面临着需要调整客户端的代码的尴尬问题，这时就不太适合noexcept

	2. 异常中立的接口，接口本身不会抛出异常但是接口内的调用会抛出异常，实际使用过程中例如：对nlohmann::json接口的封装就是这样的。因为封装的这些接口可能会发射出“路过的异常”

	3. 在使用noexcept时，容易跳进“对外声明了noexcept，而接口返回状态码等”的陷阱，使得接口调用者增加很多逻辑分支，使得程序难维护，这时使用noexcept带来的收益远低于上述陷阱带来的问题

	有些接口具备了天然不会抛出异常的属性，这时为它们增加noexcept，例如游戏里计算装备提供暴击属性值等。对于这种不依赖外部输入的接口称为宽松契约wide contracts，对于宽松契约接口加上noexcept是理所当然的。还有一种依赖于外部输入的接口称为狭隘契约narrow contracts，例如这个接口`void Fun(const std::string& strParam)`，假设依赖于参数strParam的长度必须小于32，**Scott Meyer的建议是在调用接口前调用者有义务做好长度检查，个人觉得不管是调用者做长度检查还是接口做长度检查，这一步总是不可缺少的，如果调用者做了长度检查难道接口就不需要检查了吗？作为服务器工程师没有这样的勇气——接口内不做检查，因为在服务器运行时什么情况都有可能发生，所以个人觉得外部不要做长度检查，反而由接口做长度检查，反正总是要是检查的，这样做对于调用者减轻了负担。只是个人意见，也是迷惑的地方**

	







