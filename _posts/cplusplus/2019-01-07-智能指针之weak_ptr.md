---
layout: second_template
title: 智能指针之weak_ptr
category: C++
tagline: "Supporting tagline"
tags : [C++]
permalink: weak_ptr
---

std::weak_ptr通常通过std::shared_ptr创建的智能指针，并且提供跟踪判断它是否悬挂

std::weak_ptr不能被解引用，也不能检测判空。这是因为std::weak_ptr不能被单独使用，它是std::shared_ptr作为参数的产物

std::weak_ptr 对象的大小和 std::shared_ptr 对象相同，它们都利用了同样的控制块,并且诸如构造，析构以及赋值都涉及到引用计数的原子操作

std::weak_ptr 不参与对象的共享所有权，因此不影响被指向对象的引用计数。但是，实际上在控制块中存在第二个引用计数，std::weak_ptr 来操作这个引用计数

std::weak_ptr 用来模仿类似std::shared_ptr的可悬挂指针

例如：

	auto sharePerson = std::make_shared<Person>();
	std::weak_ptr<Person> weakPerson(sharePerson);

通过以下两种方式访问std::shared_ptr所指对象：

1. std::weak_ptr::lock;它会返回一个std::shared_ptr,当std::weak_ptr已经过期时，std::shared_ptr会是null

		std::shared_ptr<Person> sharePerson = weakPerson.lock();

2. 是以 std::weak_ptr为参数，使用std::shared_ptr构造函数。这种情况下，如果std::weak_ptr过期的话，会抛出std::bad_weak_ptr异常

		std::shared_ptr<Person> sharePerson(weakPerson);

这种访问是原子操作

### 应用场景
--------------------------------------------------

1. 观察者模式

2. 解决std::shared_ptr相互引用