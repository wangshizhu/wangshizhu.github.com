---
layout: second_template
title: lambda表达式
category: C++
tagline: "Supporting tagline"
tags : [C++]
permalink: lambda
---

lambda表达式常用于创建闭包并将其用作传递给函数的实参，闭包可以复制，即对应于单独一个lambda式的闭包型别可以有多个闭包，例如：
	
	{
		int nPosX;
		
		auto c1 = [nPosX](int nPosY){return nPosX*nPosY;};
		
		auto c2 = c1;
	}
	
**闭包是lambda表达式创建的运行期对象，实例化的闭包会产生闭包类，每个lambda式都会触发编译器生成一个独一无二的闭包类，而闭包中的语句会变成它的闭包类成员函数的可执行指令。lambda表达式和闭包类存在
于编译期，闭包存在于运行期**

根据不同的捕获模式，闭包会持有数据的副本或者引用，正因为如此，在创建闭包时有以下注意事项

### 闭包注意事项
--------------------------------------------------

关于捕获我们先拿出一个规定：**捕获只能针对于在创建lambda式的作用域内可见的非静态局部变量（包括形参）**

* 以引用的方式捕获非静态局部变量

	当试图以引用的方式捕获非静态局部变量时，要注意局部变量的生命周期，避免出现**空悬引用**，例如：
		
		using FilterContainer = std::vector<std::function<bool(int)>>;
		FilterContainer filters;
		
		void addFilter()
		{
			auto nDivisor = ComputeDivisor();
			filters.emplace_back([&](int nValue){return nValue % nDivisor == 0;);
		}
		
	变量nDivisor随着函数addFilter结束而消亡了，那么添加到容器内的函数对变量nDivisor的引用会悬空，这个例子以隐式引用的方式对外部非静态局部变量捕获，显示引用也同样有空悬问题：
	
		void addFilter()
		{
			auto nDivisor = ComputeDivisor();
			filters.emplace_back([&nDivisor](int nValue){return nValue % nDivisor == 0;});
		}
	
	**显示地列出lambda表达式所依赖的局部变量或形参是很好的编程习惯**。
	
	如果闭包会立即被使用就不会存在空悬风险，即对引用变量的使用在引用变量消亡之前，例如：
	
		bool IsMultiple()
		{
			auto nDivisor = ComputeDivisor();
			
			using std::begin;
			using std::end;
			
			return std::all_of(begin(filters),end(filters),[&nDivisor](const auto& nValue){return nValue % nDivisor == 0;});
		}
	
	这个例子中形参使用了auto类型推导，这项能力只用C++14版本以后才支持。解决引用空悬问题还可以使用按值捕获，但是按值捕获也并不安全，只是在这个例子中安全，例如：
	
		void addFilter()
		{
			auto nDivisor = ComputeDivisor();
			filters.emplace_back([=](int nValue){return nValue % nDivisor == 0;});
		}
	
* 以值的方式捕获非静态局部变量

	按值捕获也并不全是安全的，例如：
	
		class CWidget
		{
		public:
			void addFilter()const;
		
		private:
			int m_nDivisor;
		};
		
		void CWidget::addFilter()const
		{
			filters.emplace_back([=](int nValue){return nValue % m_nDivisor == 0;});
		}
		
	这个例子中lambda表达式对类成员变量m_nDivisor进行按值捕获，上面提到关于捕获的规定是：**捕获只能针对于在创建lambda式的作用域内可见的非静态局部变量（包括形参）**，而类成员变量并不
	符合这个规定，但是能够编译成功，编译成功是因为编译器帮助我们添加一些必要代码：
	
		void CWidget::addFilter()const
		{
			auto objPtr = this;
			filters.emplace_back([=](int nValue){return nValue % objPtr->m_nDivisor == 0;});
		}
		
	顺便提一下，在类中的成员函数内使用其成员变量编译器内部会在成员变量前增加`this->`，这个例子中lambda表达式里使用的是this指针的副本，即捕获了this指针而不是成员变量m_nDivisor，
	风险也就在这里，当类对象被释放时lambda表达式里的指针变成空悬指针，规避这个风险应该这样编写：
	
		void CWidget::addFilter()const
		{
			auto nDivisor = m_nDivisor;
			filters.emplace_back([=](int nValue){return nValue % nDivisor == 0;});
		}
		
	更好的编码习惯：
		
		void CWidget::addFilter()const
		{
			auto nDivisor = m_nDivisor;
			filters.emplace_back([nDivisor](int nValue){return nValue % nDivisor == 0;});
		}
		
	可能会写出这样的代码：
		
		void CWidget::addFilter()const
		{
			filters.emplace_back([m_nDivisor](int nValue){return nValue % m_nDivisor == 0;});
		}
	
	这就触犯了上面提到的规定，m_nDivisor并不是非静态局部变量，编译失败
	
	如果使用的是C++14，捕获成员变量更好的方法是使用广义lambda捕获，像这样：
	
		void CWidget::addFilter()const
		{
			filters.emplace_back([nDivisor = m_nDivisor](int nValue){return nValue % nDivisor == 0;});
		}
		
	规定里提到非静态局部变量，如果一个lambda表达式采用按值捕获，在表达式内部使用**静态变量**会怎么样呢？例如：
	
		void addFilter()
		{
			static auto nDivisor = ComputeDivisor();
			
			filters.emplace_back([=](int nValue){return nValue % nDivisor == 0;});
			
			++nDivisor;
		}
		
	这段代码编译成功，只不过lambda表达式并不能捕获nDivisor，每次调用函数addFilter时添加到filters的每个lambda表达式的行为都不一样，nDivisor对应着新值，
	实际效果就是按引用捕获nDivisor
	
上面列出了这两种捕获的注意事项，只有掌握了lambda表达式的注意事项，那么在实际编码中才能运用自如
	
### 初始化捕获
--------------------------------------------------

初始化捕获是C++14才有的特性，例如上面的例子：
	
	void CWidget::addFilter()const
	{
		filters.emplace_back([nDivisor = m_nDivisor](int nValue){return nValue % nDivisor == 0;});
	}

“=”左右侧处于不同的作用域，左侧作用域是闭包类的作用域，右侧的作用域与lambda表达式定义处的作用域相同，使用初始化捕获为我们提供了两个机会：

1. 可以指定由lambda生成的闭包类中的成员变量名字
2. 可以用一个表达式初始化该成员变量

就像这个例子中，我们指定了闭包类成员变量的名字nDivisor，下面这个例子展示了用一个表达式初始化该成员变量：

	void addFilter()
	{
		filters.emplace_back([nDivisor = ComputeDivisor()](int nValue){return nValue % nDivisor == 0;});
	}
	
这两个例子对成员变量的赋值采用的都是复制的形式，如果可以更期望以移动的方式初始化成员变量，以此提高效率，例如：

	{
		auto pObj = std::make_unique<CWidget>();
		
		auto func = [pObj = std::move(pObj)](){...};
		
		// 亦或
		auto func = [pObj = std::make_unique<CWidget>()](){...};
	}
	
如果想在C++11中实现上面的效果也可以，主要的效果就是以移动的方式捕获，由于C++11的限制以移动构造的方式捕获变量是不可能的，但是可以用其他手法实现，
只不过要编写很多代码，两种实现方式，一种不采用lambda表达式，一种采用lambda表达式

* 不采用lambda表达式
	
	对于自定义的实现要支持可调用性，移动初始化成员变量
	
		class SelfClosure
		{
		public:
		
			using DataType = std::unique_ptr<CWidget>;
			explicit SelfClosure(DataType&& ptr):m_ptr(std::move(ptr))
			{
			}
		
			bool operator()()const 
			{
				...
				
				return true;
			}
		
		private:
			DataType m_ptr;
		};
		
		{
			auto fun = SelfClosure(std::make_unique<CWidget>());
		}
		
* 采用lambda表达式
	
	这里要借助std::bind，例如下面的代码：
		
		{
			std::vector<double> data;
			...
			auto fun = std::bind([](const std::vector<double>& data{},std::move(data)));
		}
	
	std::bind的第一个实参是个可调用对象，后面的实参表示传给std::bind返回的函数对象，将我们要捕获的对象移动到std::bind产生的函数对象，
	在这个函数对象内部对右值实参std::move(data)采用的是移动构造，当fun被调用时，fun内经由移动构造所得的data副本就会作为实参传递给std::bind函数的第一个实参lambda表达式副本，
	也就是说lambda表达式的形参是对经由移动构造所得的data副本的左值引用
	
	这个例子中闭包的生命周期和std::bind返回的函数对象生命周期相同
	
	总结下来，这种方式的实现就两步：
		
	1. 把需要捕获的对象移动到st::bind产生的函数对象中
	2. lambda表达式的形参以左值引用的方式指向欲捕获的对象

**在C++14中，初始化捕获是将对象移入闭包，在C++11中经由手动实现的类或借助std::bind去模拟初始化捕获**

### 对lambda表达式的形参类型使用auto&&
--------------------------------------------------