---
layout: second_template
title: 优先使用auto
category: C++
tagline: "Supporting tagline"
tags : [C++]
permalink: perfect_auto
---

### 测试环境
--------------------------------------------------
	
vs2015

C++11	

win10 64位


### auto的优点
--------------------------------------------------
	
1. auto 变量从它初始化推导出其类型，所以它们必须被初始化，规避了忘初始化的风险。对于声明一个变量`int nTmp;`也许忘了初始化，编译通过，使用时也许是0也许不是，而使用`auto nTmp = 10;`必须初始化，否则编译不通过

2. 一个使用 auto 声明持有一个封装的变量和封装体有同样的类型，也仅使用和封装体同样大小的内存。持有一个封装体的被 std::function 声明的变量的类型是 std::function 模板的一个实例，并且对任何类型只有一个固定的大小。这个内存大小可能不能满足封装体的需
求。出现这种情况时， std::function 将会开辟堆空间来存储这个封装体。导致的结果就是 std::function 对象一般会比 auto 声明的对象使用更多的内存。
通过 std::function 对象来调用一个封装体比通过 auto 对象要慢，同时也有可能抛出内存不足的异常

	例如：

		std::function<void(int,int)> varFun1 = [](int x,int y){cout<< x <<y<<endl;}
		auto varFun2 = [](int x,int y){cout<< x <<y<<endl;}

3. 可以避免错误的声明类型

	例如：

		std::vector<int> vec;
		unsigned int nSize = vec.size();

		std::unordered_map<std::string, int> unorderedMap;
		for (const std::pair<std::string, int>& one : unorderedMap)
		{
		}

	上述例子我们可能写过，对于vec.size()的返回类型是`std::vector<int>::size_type`，最终找到size_type的定义（注意我的环境）如下:

		#ifdef _WIN64
			typedef unsigned __int64 size_t;
		#else
			typedef unsigned int     size_t;

	所以这段代码`unsigned int nSize = vec.size();`在32位机器上没什么问题，在64位机器上可能结果就不正确了，如果我们使用auto就可以避免这样的问题

	再如上面的例子中
	
		for (const std::pair<std::string, int>& one : unorderedMap)
	
	在哈希表中的 std::pair 的类型不是 std::pair<std::string, int> ，而是 std::pair<const std::sting, int> 。但是这不是循环体外变量 p 的声明类型。后果就是，编译器竭尽全力去找到一种方式，把 std::pair<const std::string, int> 对象（正是哈希表中的内容）转化为 std::pair<std::string, int> 对象（ p 的声明类型）。这个过程将通过复制 m 的一个元素到一个临时对象，然后将这个临时对象和 p 绑定完成。在每个循环结束的时
	候这个临时对象将被销毁。本来想简单地将引用 p 和 m 的每个元素绑定的。 这种无意的类型不匹配可以通过 auto 解决`for (const auto& one : unorderedMap)`。 上面的例子说明显式指定的类型有可能导致隐式的转换。如果你使用 auto 作为目标变量的类型，你不必为你声明类型和用来初始化它的表达式类型之间的不匹配而担心

### 当auto推导出非预期类型时应当使用显式的类型初始化
--------------------------------------------------


