---
layout: second_template
title: 对象模型-第1章
category: C++
tagline: "Supporting tagline"
tags : [C++]
permalink: object-model-1
---

* #### 测试环境 ####
	
	vs2015

	C++11	

	win10 64位

* #### 对象模型 ####
	
	***Nonstattic data members 被置于每个class object 之中，
	static data members则被存放在个别class object 之外，
	static 和 nonstatic function members也被放在个别class object之外***

	对于虚函数virtual function 则以两个步骤支持：

	- 每个class产生出一堆指向 virtual function 的指针，被放在表格之中，
	这个表格被称为virtual table(vtbl)

	- 每个class object 被安插一个指针，指向这个表格，这个指针被称为vptr,
	vptr的setting和resetting都由每个class的constructor、destructor、copy assignment运算符
	自动完成，每个class所关联的type_info object 也经由virtual table被指出来，通常放在表格的第一个slot


* #### 单个类 ####
	

		#include "stdafx.h"
		#include <iostream>
		using namespace std;

		class Base
		{
		public:
			Base()
			{
			}
			virtual ~Base()
			{
				cout << "Base::~Base" << endl;
			}
			virtual void BaseTest()
			{
				cout << "Base::BaseTest" << endl;
			}
			virtual void BaseTest1()
			{
				cout << "Base::BaseTest1" << endl;
			}
		};

		int main()
		{
			{
				Base ObjBase;
				cout << sizeof(ObjBase) << endl;
			}

			system("pause");
		    return 0;
		}

	输出：4

	我们去掉virtual关键字，输出：1

	当我们增加virtual关键字，当创建类对象时会创建一个虚函数表指针

	若监视ObjBase变量会发现，虚函数表有3个函数指针

		第1个元素： Base::~Base
		第2个元素： Base::BaseTest
		第2个元素： Base::BaseTest1

* #### 单继承 ####
	
		class Derived1 : public Base
		{
		public:
			virtual ~Derived1()
			{
				cout << "Derived1::~Derived1" << endl;
			}
			virtual void BaseTest()
			{
				cout << "Derived1::BaseTest" << endl;
			}
			virtual void DerivedTest()
			{
				cout << "Derived1::DerivedTest" << endl;
			}
		};
		{
			Derived1 *pDerived1 = new Derived1;

			delete pDerived1;
		}

	上面的例子子类Derived1以公有继承的方式继承基类Base，
	也可以制定虚拟继承即：virtual public Base，
	***在虚拟继承的方式下，base class不管在继承体系中被派生多少次，
	base class 永远只会存在一个实例（base class suboject），
	这个属性在如今的体验好的互联网产品中的应用起到非常关键的作用***

	以上面代码为例，创建了子类Derived1指针指向子类Derived1本身，
	子类Derived1只重写了BaseTest函数，
	此时我们监视pDerived1变量，会发现子类Derived1的实例，模塑出了
	基类Base的实例，虚函数表在模塑出的基类Base实例之下，虽然虚函数表在
	模塑出的基类Base实例之下，但是发现析构函数和BaseTest函数的指针指向子类
	Derived1的析构函数和BaseTest函数。

	这种继承模型(public inheritance)

	优点：

	- 对于基类Base class members最紧凑而且最有效率的存取

	缺点：

	- 对于基类Base class members的任何改变（增加、移除、改变类型）
	都使得所有用到base class 或者 derived class 的实例必须重新编译
	

	***当父类有虚函数时，子类继承父类的虚函数表，而且虚函数的顺序是先父类的虚函数，再子类的虚函数；
	当父类的虚函数被子类重写时，则虚函数表中的父类虚函数指针要替换为子类的虚函数指针***

	此时我们监视pDerived1变量,虚函数表有3个函数指针

		第1个：指向Derived1::~Derived1
		第2个：指向Derived1::BaseTest
		第3个：指向Base::BaseTest1

* 对象的差异

	C++程序设计支持三种程序设计范式

	1. 程序模型
	像C一样

	2. 抽象数据类型模型(ADT)
	对数据的表达通过一组公有接口

	3. 面向对象模型
	此模型有共同的类型、共同的行为通过base class被封装起来

	纯粹以一种上述的范式编写，有助于整体行为的稳固，如果混合了不同的范式，
	就可能带来意想不到的结果。

	例如以一个具体的base class 实例来完成多态而不是通过base class的指针pointer或
	引用reference来完成多态。

	***OO 程序设计的多态需通过base class的指针pointer或引用reference来完成***


* #### 参考文章: ####