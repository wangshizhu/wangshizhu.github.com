---
layout: second_template
title: 移动构造函数
category: C++
tagline: "Supporting tagline"
tags : [C++]
permalink: move-constructor
---
[program_transformation_semantic]: /program-transformation-semantic
[move_right_reference]: /move&right-reference
[move_forward]: /move&forward
* * *
* #### 测试环境 ####
	
	vs2015

	C++11	

	win10 64位

* * *
* #### C++11之前的局限 ####

	在介绍移动构造函数之前先看看我们面临的问题，先看代码示例：

		class CMoveSemantic
		{
		public:
			CMoveSemantic();
			explicit CMoveSemantic(int k);
			CMoveSemantic(int k, char ch);
			CMoveSemantic(const CMoveSemantic& objMoveSemantic);
			~CMoveSemantic();

		public:
			CMoveSemantic operator+(const CMoveSemantic&f) const;
			void ShowData() const;

		private:
			void ShowObject()const;

		private:
			int n;
			char * pc;
			static int ct;
		};

		int CMoveSemantic::ct = 0;

		CMoveSemantic::CMoveSemantic()
		{
			++ct;
			n = 0;
			pc = nullptr;
			cout << "default constructor called;number of objects: " << ct << endl;
			ShowObject();
			cout << endl;
		}

		CMoveSemantic::CMoveSemantic(int k):n(k)
		{
			++ct;
			cout << "int constructor called;number of objects: " << ct << endl;
			pc = new char[n];
			ShowObject();
			cout << endl;
		}

		CMoveSemantic::CMoveSemantic(int k, char ch):n(k)
		{
			++ct;
			cout << "int char constructor called;number of objects: " << ct << endl;
			pc = new char[n];
			for (int i = 0;i < n;i++)
			{
				pc[i] = ch;
			}
			ShowObject();
			cout << endl;
		}

		CMoveSemantic::CMoveSemantic(const CMoveSemantic& objMoveSemantic):n(objMoveSemantic.n)
		{
			++ct;
			cout << "copy const called;number of objects: " << ct <<" Src object address: "<<(void *)(&objMoveSemantic)<< endl;
			pc = new char[n];
			for (int i = 0; i < n; i++)
			{
				pc[i] = objMoveSemantic.pc[i];
			}
			ShowObject();
			cout << endl;
		}
		CMoveSemantic::~CMoveSemantic()
		{
			cout << "destructor called;objects left: " << --ct << endl;
			cout << "deleted object;\n";
			ShowObject();
			delete []pc;
			cout << endl;
		}
		CMoveSemantic CMoveSemantic::operator+(const CMoveSemantic& f)const
		{
			cout << "Enter operator+()\n";
			CMoveSemantic tmp = CMoveSemantic(n + f.n);
			for (int i = 0; i < n; i++)
			{
				tmp.pc[i] = pc[i];
			}
			for (int i = n; i < tmp.n; i++)
			{
				tmp.pc[i] = f.pc[i-n];
			}
			cout << "tmp object address: " << (void *)(&tmp) << endl;;
			cout << "leaving operator+()" << endl;
			cout << endl;
			return tmp;
		}
		void CMoveSemantic::ShowObject() const
		{
			cout << "Number of element: " << n;
			cout << " Data address: " << (void*)pc << endl;
			cout << endl;
		}

		void CMoveSemantic::ShowData()const
		{
			if (n == 0)
			{
				cout << "(object empty)";
			}
			else
			{
				for (int i = 0;i < n;i++)
				{
					cout << pc[i];
				}
			}
			cout << endl;
		}

	调用代码：

		{
			CMoveSemantic one(10, 'x');
			CMoveSemantic three(20, 'o');
			CMoveSemantic four(one + three);
			cout <<"--------"<< endl;
		}

	我们猜猜`CMoveSemantic four(one + three);`这段代码调用哪些构造函数

	1. 首先函数operator+里`CMoveSemantic(n + f.n)`调用构造函数创建临时对象

	2. `CMoveSemantic tmp = CMoveSemantic(n + f.n);`调用拷贝构造

	3. `return tmp;`调用拷贝构造创建临时对象

	4. `CMoveSemantic four(one + three);`调用拷贝构造

	我们看看输出：

		Enter operator+()
		int constructor called;number of objects: 3
		Number of element: 30 Data address: 00ECA0F0


		tmp object address: 00AFF630
		leaving operator+()

		copy const called;number of objects: 4 Src object address: 00AFF630
		Number of element: 30 Data address: 00ECA780


		destructor called;objects left: 3
		deleted object;
		Number of element: 30 Data address: 00ECA0F0

	从输出上看出，只调用一次构造函数，一次拷贝构造函数。这里编译器做了优化，关于构造函数的编译器优化可以参考这篇[文章][program_transformation_semantic]，我们先不去
	关心编译器如何做的优化，这里我们可以看出变量tmp分配的内存随后被释放了，而且这块内存对于tmp没有任何意义，那么它所分配、释放的过程是被浪费掉的，那么我们想把tmp分配的内存让新对象拥有怎么办呢？传统的拷贝构造又做不到，这时移动构造函数来了，由于在移动构造函数里会对原对象做操作，所以参数不能有const，这个参数是个右值引用(关于左值、右值可以参考这篇[文章][move_right_reference])，而且以后也不能对这个实参做操作了，它已经无意义了。我们针对上面的代码增加移动构造函数

		CMoveSemantic(CMoveSemantic&& objMoveSemantic);
		CMoveSemantic::CMoveSemantic(CMoveSemantic&& objMoveSemantic):n(objMoveSemantic.n)
		{
			++ct;
			cout << "move constructor called;number of objects: " << ct << endl;
			pc = objMoveSemantic.pc;
			objMoveSemantic.pc = nullptr;
			objMoveSemantic.n = 0;
			ShowObject();
		}

	同样的调用方式，输出：

		Enter operator+()
		int constructor called;number of objects: 3
		Number of element: 30 Data address: 0094EE68


		tmp object address: 006FFDB0
		leaving operator+()

		move constructor called;number of objects: 4
		Number of element: 30 Data address: 0094EE68

		destructor called;objects left: 3
		deleted object;
		Number of element: 0 Data address: 00000000

	上面的移动构造函数的实现就是把那个无意义的对象tmp分配的内存转移到新对象，同时无意义的对象tmp里指向这块内存的指针被设置为nullptr，从而省去了重复分配的工作提高了效率

	上面的函数operator+返回的是个临时对象，而临时对象是个右值，我们知道如果实参为右值，const引用形参将指向一个以这个实参为初始化物的临时变量，从输出可以看出这个临时对象指向变量tmp，所以在没有引入移动构造函数时调用了拷贝构造函数，引入移动构造函数后调用了移动构造函数，但是平时我们有不是临时变量的情况即参数是个左值，左值无法绑定到右值，这时std::move出生了，而关于std::move和右值引用可以参考这篇[文章][move_forward]。还有移动赋值运算符，移动赋值运算符的实现：

		CMoveSemantic& operator=(CMoveSemantic&& objMoveSemantic);
		CMoveSemantic& operator=(const CMoveSemantic& objMoveSemantic);

		CMoveSemantic& CMoveSemantic::operator=(CMoveSemantic&& objMoveSemantic)
		{
			cout << "move assignment called;"<< endl;
			if (this == &objMoveSemantic)
			{
				return *this;
			}
			delete[]pc;
			n = objMoveSemantic.n;
			pc = objMoveSemantic.pc;
			objMoveSemantic.pc = nullptr;
			objMoveSemantic.n = 0;
			ShowObject();
			return *this;
		}

		CMoveSemantic& CMoveSemantic::operator=(const CMoveSemantic& objMoveSemantic)
		{
			cout << "copy assignment called;" << endl;
			if (this == &objMoveSemantic)
			{
				return *this;
			}
			delete[]pc;
			n = objMoveSemantic.n;
			pc = new char[n];
			for (int i = 0; i < n;i++)
			{
				pc[i] = objMoveSemantic.pc[i];
			}
			return *this;
		}

* * *
* #### 最后 ####
	
	C++11增加了两个特殊的成员函数：

	1. 移动构造函数

	2. 移动赋值运算符

	如果没有提供移动构造函数而代码又需要它，将使用复制构造函数，如果没有定义复制构造函数，则编译报错，而定义移动构造函数没有定义复制构造函数，当进行调用复制构造函数，编译器报错

	赋值运算符没有定义对应的赋值运算符函数也同样编译不通过
