---
layout: second_template
title: 重载重写隐藏
category : C++
tagline: "Supporting tagline"
tags : [C++]
permalink: overload&override&hide
---

* #### 测试环境 ####
	
	vs2015

	C++11	

	win10 64位

* #### 重载的特征 ####

	1. 相同的范围（在同一个类中）
	2. 函数名字相同
	3. 参数不同
	4. virtual 关键字可有可无
	5. 返回值可相同也可不同

* #### 重写的特征 ####

	在派生类中覆盖基类中的同名函数，要求基类函数必须是虚函数

	1. 不同范围（基类、子类）
	2. 函数名、参数列表、返回值相同
	3. 基类函数有virtual
	4. 子类函数virtual可有可无
	5. 当子类指针指向子类本身时，若子类重写函数是一个重载版本，那么基类的其他同名重载函数将在子类中隐藏

	父类指针和引用指向子类的实例时，通过父类指针或引用可以调用子类的函数（多态）

* #### 隐藏的特征 ####
	
	1. 不同范围（基类、子类）
	2. 当子类指针指向子类本身时，如果子类的函数与基类的函数同名，参数不同，
	此时，不论有无virtual关键字，基类的函数将被隐藏
	3. 当基类指针指向子类本身时，如果子类的函数与基类的函数同名，参数相同，基类函数没有virtual关键字，
	此时通过基类指针调用子类函数时，其实是调用基类函数

* #### 验证 ####
	
	`
	class Base
	{
	public:
		void Test()
		{
			cout << "Base::Test()" << endl;
		}
		virtual void Test(int nParam)
		{
			cout << "Base::Test(int nParam)" << endl;
		}
	};
	`

	重载

	`
	// overload
	{
		Base b;
		b.Test();
		b.Test(10);
	}
	`

	输出：

	`
	Base::Test()
	Base::Test(int nParam)
	`

	重写

		class Drived1 : public Base
		{
		public:
			void Test(int nParam)
			{
				cout << "Drived1::Test(int nParam)" << endl;
			}
		};
		// 当Drived1子类指针指向Drived1时，此时调用基类的无参Test函数，编译期就不通过
		// 显示Drived1没有无参Test函数，正验证重写的第5特征
		{
			// overwrite
			Drived1* pDrived1 = new Drived1;
			pDrived1->Test();
			pDrived1->Test(20);
			delete pDrived1;
		}
		// 若基类Base指针指向子类Drived1时，此时调用基类的无参Test函数，没有编译错误
		{
			// overwrite
			Base* pBase = new Drived1;
			pBase->Test();
			pBase->Test(20);
			delete pBase;
		}

	输出：

	`
	Base::Test()
	Drived1::Test(int nParam)
	`

	隐藏

	先看看隐藏的第2特征:

		class Drived1 : public Base
		{
		public:
			void Test(int nParam1,short nParam2)
			{
				cout << "Drived1::Test(int nParam1,short nParam2)" << endl;
			}
		};
		// 当Drived1子类指针指向Drived1时，此时调用基类的无参Test和有参函数，编译期就不通过
		{
			// hide
			Drived1* pDrived1 = new Drived1;
			pDrived1->Test();
			pDrived1->Test(20);
			delete pDrived1;
		}

	隐藏的第3特征:

		class Base
		{
		public:
			void Test()
			{
				cout << "Base::Test()" << endl;
			}
			void Test(int nParam)
			{
				cout << "overload  Base::Test(int nParam)" << endl;
			}
		};
		class Drived1 : public Base
		{
		public:
			void Test(int nParam)
			{
				cout << "Drived1::Test(int nParam)" << endl;
			}
		};
		{
			Base* pBase = new Drived1;
			pBase->Test();
			pBase->Test(20);
			delete pBase;
		}

	输出:

	`
	Base::Test()
	Base::Test(int nParam)
	`

	很明显调用基类函数