---
layout: second_template
title: 模板
category: C++
tagline: "Supporting tagline"
tags : [C++]
permalink: template
---
[constexpr]:/constexpr
[template_type_deduction]:/template-type-deduction

在这篇[文章][template_type_deduction]提到了模板类型推导，关于模板的知识还不够全面，通过这篇文章再结合实际生产中遇到相关问题进一步完善模板相关知识

### 模板
--------------------------------------------------

模板可以包含类型参数和非类型参数，像下面这个模板同时包含了这两个参数：
	
	template<typename T,int N>
	class Test;
	
T为类型参数，N为非类型参数，**N必须是个编译期已知的值**，关于编译期已知值可以参考这篇[文章][constexpr]，上面的模板声明和C++11中的STL模板Array一致，非类型参数的类型有一定限制，可以是整型、枚举、
引用、指针、自定义类型，下面列出了合法使用和不合法使用：
	
	// NO:
	template<typename T,double N>
	class Test;
	
	// YES:
	template<typename T,double* N>
	class Test;
	
模板内代码不能修改参数的值，也不能使用参数的地址，不合法的使用：
	
	// NO:
	N++；
	// NO:
	&N;

	
类型参数可以指定默认类型，如：

	template<typename T,typename U = int>
	class TestDefault;
	
同时可以递归使用模板，例如上面提到Test模板：
	
	Test<Test<int,2>,10> obj;
