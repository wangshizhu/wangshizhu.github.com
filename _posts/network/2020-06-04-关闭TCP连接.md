---
layout: second_template
title: 关闭TCP连接
category: network
tagline: "Supporting tagline"
tags : [network]
permalink: close-connection
---

[TCP_UDP]:/TCP&UDP

关闭一个TCP连接有两个函数可调用：

* close
	
	函数签名：int close(int sockfd)

* shutdown()
	
	函数签名：int shutdown(int sockfd, int howto)
	
### 使用close函数
--------------------------------------------------

对已连接的套接字执行close操作，若成功则为0，若出错则为-1

这个函数会对套接字引用计数减1，当套接字引用计数到0，就会对套接字进行彻底释放，并且会关闭 TCP **两个方向**的数据流

因为套接字可以被多个进程共享，所以就有了套接字引用计数，例如通过fork的方式产生子进程，套接字引用计数+1， 如果调用一次close函数，套接字引用计数就会-1。
这就是套接字引用计数的含义

当套接字引用计数为0时，连接的两个方向被关闭

* 在输入方向

	系统内核会将该套接字设置为不可读，任何读操作都会返回异常
	
* 在输出方向
	
	系统内核尝试将发送缓冲区的数据发送给对端，并最后向对端发送一个FIN报文，接下来如果再对该套接字进行写操作会返回异常。如果对端没有检测到套接字已关闭，
还继续发送报文，就会收到一个RST报文，**所以记得处理RST报文，RST报文产生的错误在Windows平台上对应的错误码为WSAECONNRESET，在Linux平台上对应的错误码为ECONNRESET**

### 使用shutdown函数
--------------------------------------------------

close函数并不能直接的关闭连接的一个方向，但shutdown可以，从上面shutdown函数签名看出，shutdown函数有两个参数，下面是对howto参数的解释：

* SHUT_RD(0)
	
	**关闭连接的“读”这个方向，对该套接字进行读操作直接返回EOF。从数据角度来看，套接字上接收缓冲区已有的数据将被丢弃，如果再有新的数据流到达，
会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下发送端根本不知道数据已经被丢弃了**
 
* SHUT_WR(1)
	
	**关闭连接的“写”这个方向，这就是常被称为”半关闭“的连接。此时，不管套接字引用计数的值是多少，都会直接关闭连接的写方向。套接字上发送缓冲区已有的数据将被立即发送出去，
并发送一个FIN报文给对端。应用程序如果对该套接字进行写操作会报错**

* SHUT_RDWR(2)
	
	相当于 SHUT_RD 和 SHUT_WR 操作各一次，关闭套接字的读和写两个方向
	
### 两个函数的差别
--------------------------------------------------

* close会关闭连接，并释放所有连接对应的资源，而shutdown并不会释放掉套接字和所有的资源

* close存在引用计数的概念，并**不一定**导致该套接字不可用；shutdown则不管引用计数，直接使得该套接字不可用，如果有别的进程企图使用该套接字，将会受到影响

* 由于有引用计数概念的存在，close**不一定**会发出FIN结束报文，除非引用计数为0，而shutdown则总是会发出FIN结束报文

### 验证
--------------------------------------------------

### CLOSE_WAIT
--------------------------------------------------

对于服务端程序如果实际生产过程中出现大量CLOSE_WAIT连接，这些CLOSE_WAIT连接保持了很长时间，说明服务端程序出现了**套接字泄露**，结合这篇[文章][TCP_UDP]提到的TCP四次挥手，服务端程序出现CLOSE_WAIT连接，
通常是客户端程序即主动关闭方发送了FIN包，即发起了第一次挥手，而服务端程序没有处理FIN包，即没有调用close，从而导致套接字泄露

如果出现大量的CLOSE_WAIT连接，常见的现象就是新连接无响应，大量的CLOSE_WAIT连接占用着大量系统资源，目前来看，应对策略就是分析服务端应用程序，从服务端应用程序端找到泄露点，
找到后重启服务端应用程序

还有一个点需要验证，这篇[文章][TCP_UDP]提到的挥手步骤3中：**应用程序可以通过read调用来感知这个FIN包，这个EOF会被放在已排队等候的其他已接收的数据之后**。验证思路：

* 服务端程序感知新连接后，sleep一段时间

* 在服务端程序sleep的这段时间，客户端程序发消息，随后kill掉客户端程序

* 观察服务端对这个连接的状态变化，以及过了sleep时间后服务端程序对这个连接的处理

在过了sleep时间之前一定做完的几件事：
	
1. 客户端程序发起连接

2. 服务端观察连接状态

3. 客户端程序发消息

4. kill掉客户端程序

5. 服务端再次观察连接状态

服务端程序：
	
	./test0306 --listen_backlog=3 --accept_sleep=7000
	
客户端程序：

	./client -p 5701 --dest_host=IP.IP.IP.IP --dest_port=5700
	
服务端对于这个连接的变化如下：

	netstat -alepn|grep 5700
	tcp        1      0 0.0.0.0:5700            0.0.0.0:*               LISTEN      0          1604060    20684/./test0306    
	tcp       16      0 *.*.*.*:5700       		*.*.*.*:18186    		ESTABLISHED 0          0
	
客户端程序发消息完毕后，kill掉客户端程序：

	netstat -alepn|grep 5700
	tcp        0      0 0.0.0.0:5700            0.0.0.0:*               LISTEN      0          1604060    20684/./test0306    
	tcp       17      0 *.*.*.*:5700       		*.*.*.*:18186    		CLOSE_WAIT  0          1604096    20684/./test0306
	
过了sleep时间后，服务端程序log输出：

	log:info, function: HandleInput, line_num: 57, msg: a connect accept,remote socket address,ip:*.*.*.*,port:18186
	
	log:debug, function: Msg2Handler, line_num: 25, msg: msg2,msg_id:2,msg_len:10,data:213
	log:debug, function: OnGetError, line_num: 147, msg: TcpPacketInputHandler get socket error fd:4
	
	log:debug, function: ~Session, line_num: 17, msg: Session have released
	...
	
从服务端程序log来看，服务端程序先处理消息，随后处理了FIN包，证明了验证的点是正确的

### TIME_WAIT
--------------------------------------------------

