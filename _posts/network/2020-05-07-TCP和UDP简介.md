---
layout: second_template
title: TCP和UDP简介
category: network
tagline: "Supporting tagline"
tags : [network]
permalink: TCP&UDP
---

了解TCP和UDP之前先了解socket，使用TCP和UDP通信socket必不可少

### socket
--------------------------------------------------

socket简单的理解为软件与硬件之间沟通的桥梁，可以理解为一个电话，创建socket使用的接口：
	
	int socket(int domain, int type, int protocol)
	
* 参数domain
	
	domain表示地址族，常用地址族有AF_LOCAL，AF_INET，AF_INET6
	
	AF_LOCAL：表示的是本地地址，对应的是 Unix套接字，这种情况一般用于本地socket通信，也可以写成AF_UNIX、AF_FILE
	
	AF_INET：因特网使用的 IPv4 地址
	
	AF_INET6：因特网使用的 IPv6 地址

* 参数type

	SOCK_STREAM: 表示的是字节流，对应TCP协议
	
	SOCK_DGRAM： 表示的是数据报，对应UDP协议
	
	SOCK_RAW：表示的是原始套接字

* 参数protocol
	
	此参数原本是用来指定通信协议的，现在基本废弃，传入0即可
	
* 返回值
	
	当返回值<=0时，说明创建失败
	
### 套接字地址格式
--------------------------------------------------

有了电话，对于连接发起方（主动拨打电话方），需要知道对方的电话号码，电话号码有可能是固定电话、手机，固定电话有固定电话的格式，手机有手机的格式，所以就有了对格式解析的方式，分为：

* 通用地址格式
	
	通用地址格式结构体：
		
		/* POSIX.1g 规范规定了地址族为2字节的值. */
		typedef unsigned short int sa_family_t;
		
		/* 描述通用套接字地址 */
		struct sockaddr
		{ 
			/* 地址族. 16-bit*/ 
			sa_family_t sa_family; 
			
			/* 具体的地址值 112-bit */ 
			char sa_data[14]; 
		};
		
	sa_family表示地址族，表示以什么方式对地址进行解析、保存，就像手机格式、固定电话格式，就是上面提到的
	
	sa_data表示具体地址了，就像电话号码
	
* IPv4地址格式
	
	IPv4地址格式的结构体：
	
		/* IPV4套接字地址，32bit值. */
		typedef uint32_t in_addr_t;
		
		struct in_addr 
		{ 
			in_addr_t s_addr; 
		}; 
		
		/* 描述IPV4的套接字地址格式 */
		struct sockaddr_in 
		{ 
			/* 地址族. 16-bit*/ 
			sa_family_t sin_family; 
			
			/* 端口号 16-bit*/ 
			in_port_t sin_port; 
			
			/* Internet address. 32-bit */ 
			struct in_addr sin_addr; 
			
			/* 这里仅仅用作占位符，不做实际用处 */ 
			unsigned char sin_zero[8]; 
		};
		
	sun_family表示地址族，固定为AF_INET
	
	sin_port表示要监听（对于服务端来说）或者连接（对于客户端来说）的端口号，端口号占16位，也就是说2的16次方（65535）个端口号可用，去掉保留的端口号，剩下的就是用户可用的
	
	sin_addr表示ip地址，占32位，也就是说可用2的32次方个ip地址，但是依然不够用，后来有了IPv6
	
	对于连接的发起方可以这样编写：
	
		int network::SocketWrapper::Connect(const char* ip, short port)
		{
			struct sockaddr_in server_sock_addr;
			memset(&server_sock_addr, 0, sizeof(server_sock_addr));
		
			server_sock_addr.sin_family = AF_INET;
			server_sock_addr.sin_port = htons(port);
			IPToN(AF_INET, ip, &server_sock_addr.sin_addr);
		
			return ::connect(socket_, (struct sockaddr*)&server_sock_addr, sizeof(server_sock_addr));
		}
	
* IPv6地址格式
	
	IPv6地址格式的结构体：
	
		struct sockaddr_in6 
		{ 
			/* 16-bit */
			sa_family_t sin6_family; 
			
			/* 传输端口号 # 16-bit */ 
			in_port_t sin6_port; 
			
			/* IPv6流控信息 32-bit*/
			uint32_t sin6_flowinfo;  
			
			/* IPv6地址128-bit */
			struct in6_addr sin6_addr;  
			
			/* IPv6域ID 32-bit */
			uint32_t sin6_scope_id;  
		};
	
	sun_family表示地址族，固定为AF_INET6
	
	sin6_addr表示ip地址，占128位，那么可用的地址比IPv4大的太多了
	
* 本地地址格式
	
	IPv4地址格式和IPv6地址格式都是因特网套接字的格式，本地套接字地址格式：
	
		struct sockaddr_un 
		{ 
			/* 固定为 AF_LOCAL */
			unsigned short sun_family; 
			
			/* 路径名 */
			char sun_path[108]; 
		};
		
	sun_family表示地址族，固定为AF_LOCAL
	
下图可以清晰的看到这几种地址格式：

![Alt text][socket_addr]

[socket_addr]: assets/themes/my_blog/img/socket_addr.jpg