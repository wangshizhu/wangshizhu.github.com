---
layout: second_template
title: TCP和UDP简介
category: network
tagline: "Supporting tagline"
tags : [network]
permalink: TCP&UDP
---

了解TCP和UDP之前先了解socket，使用TCP和UDP通信socket必不可少

### socket
--------------------------------------------------

socket简单的理解为软件与硬件之间沟通的桥梁，可以理解为一个电话，创建socket使用的接口：
	
	int socket(int domain, int type, int protocol)
	
* 参数domain
	
	domain表示地址族，常用地址族有AF_LOCAL，AF_INET，AF_INET6
	
	AF_LOCAL：表示的是本地地址，对应的是 Unix套接字，这种情况一般用于本地socket通信，也可以写成AF_UNIX、AF_FILE
	
	AF_INET：因特网使用的 IPv4 地址
	
	AF_INET6：因特网使用的 IPv6 地址

* 参数type

	SOCK_STREAM: 表示的是字节流，对应TCP协议
	
	SOCK_DGRAM： 表示的是数据报，对应UDP协议
	
	SOCK_RAW：表示的是原始套接字

* 参数protocol
	
	此参数原本是用来指定通信协议的，现在基本废弃，传入0即可
	
* 返回值
	
	当返回值<=0时，说明创建失败
	
### 套接字地址格式
--------------------------------------------------

有了电话，对于连接发起方（主动拨打电话方），需要知道对方的电话号码，电话号码有可能是固定电话、手机，固定电话有固定电话的格式，手机有手机的格式，所以就有了对格式解析的方式，分为：

* 通用地址格式
	
	通用地址格式结构体：
		
		/* POSIX.1g 规范规定了地址族为2字节的值. */
		typedef unsigned short int sa_family_t;
		
		/* 描述通用套接字地址 */
		struct sockaddr
		{ 
			/* 地址族. 16-bit*/ 
			sa_family_t sa_family; 
			
			/* 具体的地址值 112-bit */ 
			char sa_data[14]; 
		};
		
	sa_family表示地址族，表示以什么方式对地址进行解析、保存，就像手机格式、固定电话格式，就是上面提到的
	
	sa_data表示具体地址了，就像电话号码
	
* IPv4地址格式
	
	IPv4地址格式的结构体：
	
		/* IPV4套接字地址，32bit值. */
		typedef uint32_t in_addr_t;
		
		struct in_addr 
		{ 
			in_addr_t s_addr; 
		}; 
		
		/* 描述IPV4的套接字地址格式 */
		struct sockaddr_in 
		{ 
			/* 地址族. 16-bit*/ 
			sa_family_t sin_family; 
			
			/* 端口号 16-bit*/ 
			in_port_t sin_port; 
			
			/* Internet address. 32-bit */ 
			struct in_addr sin_addr; 
			
			/* 这里仅仅用作占位符，不做实际用处 */ 
			unsigned char sin_zero[8]; 
		};
		
	sun_family表示地址族，固定为AF_INET
	
	sin_port表示要监听（对于服务端来说）或者连接（对于客户端来说）的端口号，端口号占16位，也就是说2的16次方（65535）个端口号可用，去掉保留的端口号，剩下的就是用户可用的
	
	sin_addr表示ip地址，占32位，也就是说可用2的32次方个ip地址，但是依然不够用，后来有了IPv6
	
	对于连接的发起方可以这样编写：
	
		int network::SocketWrapper::Connect(const char* ip, short port)
		{
			struct sockaddr_in server_sock_addr;
			memset(&server_sock_addr, 0, sizeof(server_sock_addr));
		
			server_sock_addr.sin_family = AF_INET;
			server_sock_addr.sin_port = htons(port);
			IPToN(AF_INET, ip, &server_sock_addr.sin_addr);
		
			return ::connect(socket_, (struct sockaddr*)&server_sock_addr, sizeof(server_sock_addr));
		}
	
* IPv6地址格式
	
	IPv6地址格式的结构体：
	
		struct sockaddr_in6 
		{ 
			/* 16-bit */
			sa_family_t sin6_family; 
			
			/* 传输端口号 # 16-bit */ 
			in_port_t sin6_port; 
			
			/* IPv6流控信息 32-bit*/
			uint32_t sin6_flowinfo;  
			
			/* IPv6地址128-bit */
			struct in6_addr sin6_addr;  
			
			/* IPv6域ID 32-bit */
			uint32_t sin6_scope_id;  
		};
	
	sun_family表示地址族，固定为AF_INET6
	
	sin6_addr表示ip地址，占128位，那么可用的地址比IPv4大的太多了
	
* 本地地址格式
	
	IPv4地址格式和IPv6地址格式都是因特网套接字的格式，本地套接字地址格式：
	
		struct sockaddr_un 
		{ 
			/* 固定为 AF_LOCAL */
			unsigned short sun_family; 
			
			/* 路径名 */
			char sun_path[108]; 
		};
		
	sun_family表示地址族，固定为AF_LOCAL
	
下图可以清晰的看到这几种地址格式：

![Alt text][socket_addr]

[socket_addr]: assets/themes/my_blog/img/socket_addr.jpg

### 创建TCP服务
--------------------------------------------------

创建一个简单的TCP服务需要以下几步：

1. 创建socket
	
	上面提到的系统函数
	
		int socket(int domain, int type, int protocol)
	
2. bind
	
	bind函数就是把第1步创建的套接字和套接字地址绑定，就像去电信运营商申请电话号码一样，bind函数签名如下：
		
		int bind(int fd, sockaddr * addr, socklen_t len)
		
	参数fd：第1步创建的套接字
	
	参数addr：通用地址格式指针
	
	参数len：自己选择的地址格式长度
		
	摘自网络库的一段代码：
	
		int network::SocketWrapper::bind(const char* ip, short port)
		{
			// 绑定到port和ip
			struct sockaddr_in server_sock_addr;
		
			// IPV4
			server_sock_addr.sin_family = AF_INET;
			// 指定端口
			server_sock_addr.sin_port = htons(port);
		
			IPToN(AF_INET, ip, &server_sock_addr.sin_addr);
		
			return ::bind(socket_, (struct sockaddr *) &server_sock_addr, sizeof(server_sock_addr));
		}
		
	这段代码使用了IPv4地址格式，当调用系统函数::bind时需要将IPv4地址格式转换成了通用地址格式，对于::bind函数的实现者需要处理不同地址格式，那么就需要调用者传递其选择的地址格式长度，
	这样就可以对地址进行解析
	
	这个函数有两个参数——ip、port，如果服务程序接收的是本机的消息，并不区分网卡，即本机的任何ip即可，这种情况可以利用通配地址来实现：
		
		struct sockaddr_in name;
		/* IPV4通配地址 */
		name.sin_addr.s_addr = htonl (INADDR_ANY); 
		/* IPv6通配地址 */
		name.sin_addr.s_addr = htonl (IN6ADDR_ANY);
		
	同样的port也可以交给系统来选择，即由系统选择一个未使用端口，传递为0的参数即可，但是对于服务器程序这样做并不是一个明智的选择，因为服务器程序要将端口暴露给客户端
		
3. listen
	
	有了电话，也注册了电话号码，还需要接上电话线，接电话线的过程就是这一步——listen，listen的函数签名：
		
		int listen (int socketfd, int backlog)
		
	参数socketfd：第1步创建的套接字（电话）
	
	参数backlog：未完成连接队列的大小，这个参数的大小决定了可以接收的并发数目（这部电话和现实中的电话不同的是：现实中一部电话只能接受一个用户拨打，
	服务器程序的电话，可以接受多个用户拨打）。这个参数越大，并发数目理论上也会越大。但是参数过大也会占用过多的系统资源，一些系统，比如Linux并不允许对这个参数进行改变
	
4. accept
	
	有人打电话了，服务器程序要接起电话，当电话铃响起了，**TCP连接已经完成了三次握手，连接已经建立**，accept函数签名:
	
		int accept(int listensockfd, struct sockaddr *cliaddr, socklen_t *addrlen)
		
	参数listensockfd：第1步创建的套接字（电话）
	
	参数cliaddr：通过指针方式获取的客户端的地址
	
	参数addrlen：客户端的地址长度
	
	返回值：**新的套接字**，代表与客户端的一条连接，以后服务器与这个客户端的通信就使用这个套接字，断开连接时回收掉的也是这个套接字，这个连接不复存在了
	
5. recv
	
	接起电话后，听对方说话，讲出自己想说的话，这个过程就是通信，recv函数签名：
	
		int recv(socket s, char *buf, int len,int flags)
		
	参数s：accept函数返回的新套接字
	
	参数buf：应用程序缓冲区
	
	参数len：应用程序**想要**读取的字节数
	
	参数flags：标志位，通常传递0
	
	返回值：**实际**读取的字节数
	
	对这个函数的调用有很多规则，后面会用一个篇幅来专门详细讲
	
上面简单的列举了创建一个简单的TCP服务需要的步骤，达到生产级别还很远，先有个宏观概念，会有详细文章一层一层剖析

### 创建TCP连接
--------------------------------------------------

有了服务器程序，还需要创建发起连接的客户端程序，创建客户端程序需要以下步骤：

1. 创建socket
	
	和创建TCP服务程序一样，先有电话
	
2. connect
	
	和服务器建立连接，**这里有一个问题：在第1步和第2步之间不需要bind函数吗？即打电话场景中的去电信运营商申请电话号码一样**，先记下这个问题，先看看connect函数签名：
	
		int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)
		
	参数sockfd：第1步创建的套接字
	
	参数servaddr：服务器地址格式
	
	参数addrlen：地址格式长度
	
	摘自网络库的一段代码：
	
		int network::SocketWrapper::Connect(const char* ip, short port)
		{
			struct sockaddr_in server_sock_addr;
			memset(&server_sock_addr, 0, sizeof(server_sock_addr));
		
			server_sock_addr.sin_family = AF_INET;
			server_sock_addr.sin_port = htons(port);
			IPToN(AF_INET, ip, &server_sock_addr.sin_addr);
		
			return ::connect(socket_, (struct sockaddr*)&server_sock_addr, sizeof(server_sock_addr));
		}
		
	参数ip：服务器程序ip
	
	参数port：服务器程序监听的端口
	
	返回值：连接结果，当返回值<0时说明连接出错了，此时可以调用系统函数查看这个错误码，**连接过程会触发TCP三次握手**，连接成功也就意味着三次握手成功，连接出错通常有以下几种情况：
	
	* 三次握手无法建立
	
		客户端发出的 SYN 包没有任何响应，于是返回 TIMEOUT 错误。这种情况比较常见的原因是对应的服务端 IP 写错
	
	* 客户端收到了 RST（复位）回答，这时候客户端会立即返回 CONNECTION REFUSED 错误
	
		这种情况比较常见于客户端发送连接请求时的请求端口写错，因为RST是TCP在发生错误时发送的一种TCP分节。产生RST的三个条件是：
		
		1. 目的地为某端口的 SYN 到达，然而该端口上没有正在监听的服务器（如前所述）
		2. TCP 想取消一个已有连接
		3. TCP 接收到一个根本不存在的连接上的分节
		
	* 客户发出的 SYN 包在网络上引起了"destination unreachable"
	
		即目的不可达的错误。这种情况比较常见的原因是客户端和服务器端路由不通
	
3. send
	
	连接建立后，就可以收发消息了，这里使用的send函数签名是这样的：
	
		int send (int socketfd, char *buffer, int size, int flags)
		
	参数socked：第1步创建的socket
	
	参数buffer：客户端程序待发送消息缓存，
	
	参数size：**想要**发送的消息长度
	
	参数flags：标记位，可以指定选项是否发送带外数据，带外数据，是一种基于 TCP 协议的紧急数据，用于客户端-服务器在特定场景下的紧急处理
	
	返回值：**实际**发送的消息长度
	
	关于发送消息的接口不只有这一个，并且对于返回值的处理，后面会详细介绍，至此一个简单地基于TCP客户端-服务器通信程序可以编写了，距离生产级别还很远，一层一层的拨开面纱
	
### TCP三次握手
--------------------------------------------------